/*
 * Kernel Offset Generator Program
 */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <assert.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <mach/mach_types.h>
#include <mach-o/loader.h>

typedef struct {
    const char* name;
    const uint8_t* patch;
    uint32_t size;
} patches;

uint8_t CodeSignEnforcement[] = {0xa2, 0x6a, 0x1b, 0x68, 0x00, 0x2b, 0x04, 0xbf};
uint8_t VmMapEnter[] = {0x06, 0x28, 0x04, 0xbf, 0x19, 0x98, 0x00, 0x28};
uint8_t TaskForPid0[] = {0x01, 0x91, 0x06, 0xd1, 0x02, 0xa8, 0x41, 0x46};
uint8_t PE_I_can_has_debugger[] = {0x09, 0x68, 0x01, 0x60, 0x01, 0x48, 0x00, 0x68, 0x70, 0x47};
uint8_t AmfiPatch1[] = {0xd0, 0x47, 0x01, 0x21, 0x40, 0xb1, 0x13, 0x35};
uint8_t SandboxPatch1[] = {0x00, 0x78, 0x10, 0xf0, 0x04, 0x0f, 0x04, 0xd0};
uint8_t AmfiKill[] = {0x09, 0x21, 0xba, 0x4a, 0x28, 0x46, 0x90, 0x47, 0x19, 0xe1, 0x4f, 0xf0, 0xff, 0x32};
uint8_t FlushIcache[] = {0x00, 0x00, 0xa0, 0xe3, 0x5e, 0x0f, 0x07, 0xee, 0x40, 0x00, 0x80, 0xe2, 0x02, 0x0a, 0x10, 0xe3, 0xfb, 0xff, 0xff, 0x0a, 0x02, 0x0a, 0xc0, 0xe3, 0x01, 0x01, 0x90, 0xe2, 0xf8, 0xff, 0xff, 0x3a, 0x02, 0x00, 0xa0, 0xe3};
uint8_t ClearDcache[] = {0x00, 0x00, 0xa0, 0xe3, 0x15, 0x0f, 0x07, 0xee, 0x1e, 0xff, 0x2f, 0xe1};

patches kernel_patches[] = {
    {"KERNEL_CS_ENFORCEMENT", CodeSignEnforcement, sizeof(CodeSignEnforcement)},
    {"KERNEL_VM_ENTER", VmMapEnter, sizeof(VmMapEnter)},
    {"KERNEL_TASK_FOR_PID0", TaskForPid0, sizeof(TaskForPid0)},
    {"KERNEL_PE_DEBUGGER", PE_I_can_has_debugger, sizeof(PE_I_can_has_debugger)},
    //    {"KERNEL_AMFI", AmfiPatch1, sizeof(AmfiPatch1)},
    //    {"KERNEL_SANDBOX", SandboxPatch1, sizeof(SandboxPatch1)},
    //    {"KERNEL_AMFI_KILL", AmfiKill, sizeof(AmfiKill)},
    {"KERNEL_FLUSH_ICACHE", FlushIcache, sizeof(FlushIcache)},
    {"KERNEL_FLUSH_DCACHE", ClearDcache, sizeof(ClearDcache)},
    {NULL, NULL},
};

#define VMADDR      0x80001000  /* Kernel is mapped linearly. */

void patch_find_part1(void* p, int sz)
{
    printf("#\n"
           "# This file was machine generated by the kernel offset generator.\n"
           "#\n");
    
    int i;
    // XXX: Bad.
    for(i = 0; i <= sz - 8192; i++) {
        patches *cur = &kernel_patches[0];
        while(cur && (cur->name != NULL)) {
            if(!memcmp((void*)(p + i), cur->patch, cur->size)) {
                int soffset = 0;
                if(cur->patch == PE_I_can_has_debugger)
                    soffset = 6;
                printf("%s = 0x%08x\n", cur->name, i + VMADDR + soffset);
            }
            cur++;
        }
    }
    
    return;
}

void patch_find_part2(void* p, int sz)
{
    char unix_syscall_str[] = "\"unix_syscall: unknown return type\"";    
    int i, first_ref = 0;
    uint32_t syscall_offset;
    
    // THIS IS PROBABLY BAD AND ALL WRONG !!! 
    
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), unix_syscall_str, strlen(unix_syscall_str))) {
            if(first_ref == 0) {
                first_ref = 1;
            } else {
                syscall_offset = VMADDR + i;
                break;
            }
        }
    }
    
    /* Pass 2, look for unix_syscall */
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), &syscall_offset, sizeof(uint32_t))) {
            syscall_offset = i;
            break;
        }
    }
    
    uint32_t kernel_sysent_call0 = *(uintptr_t*)((uintptr_t)p + (uintptr_t)(syscall_offset - 4)) + 4;
    
    printf("KERNEL_SYSCALL0 = 0x%08x\n", kernel_sysent_call0);
    printf("KERNEL_SYSCALL0_VALUE = 0x%08x\n", *(uintptr_t*)(kernel_sysent_call0 - VMADDR + (uintptr_t)p));

    char pmap_page_protect_str[] = "\"pmap_page_protect: bad pve entry pve_p=%p pmap=%p, pte=0x%x, sh";
    uint32_t pmap_page_protect_krnl;
    
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), pmap_page_protect_str, strlen(pmap_page_protect_str))) {
            pmap_page_protect_krnl = VMADDR + i;
            break;
        }
    }
    
    /* Pass 4, look for pmap_page_protect */
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), &pmap_page_protect_krnl, sizeof(uint32_t))) {
            pmap_page_protect_krnl = i;
            break;
        }
    }
    
    printf("KERNEL_NX_ENABLE = 0x%08x\n", *(uintptr_t*)(pmap_page_protect_krnl + (uintptr_t)p + 4));

    char iolog_str[] = "%s: error mapping interrupt[%d]\n";
    uint32_t iolog_krnl;
    
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), iolog_str, strlen(iolog_str))) {
            iolog_krnl = VMADDR + i;
            break;
        }
    }
    
    /* Pass 4, look for pmap_page_protect */
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), &iolog_krnl, sizeof(uint32_t))) {
            iolog_krnl = i;
            break;
        }
    }
    
    printf("KERNEL_IOLOG = 0x%08x\n", *(uintptr_t*)(iolog_krnl + (uintptr_t)p + 4));
}

int main(int argc, char* argv[]) {
    assert(argv[1] != NULL);
    
    struct stat buf;
    assert(stat(argv[1], &buf) != -1);
    
    int fd = open(argv[1], O_RDONLY);
    assert(fd != -1);
    
    void* p = mmap(NULL, buf.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    
    patch_find_part1(p, buf.st_size);
    patch_find_part2(p, buf.st_size);
    
    munmap(p, buf.st_size);
    close(fd);
    
    return 0;
}
