/*
 * Kernel Offset Generator Program
 */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <assert.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <mach/mach_types.h>
#include <mach-o/loader.h>

typedef struct {
    const char* name;
    const uint8_t* patch;
    uint32_t size;
} patches;

uint8_t TaskForPid0[] = {0x00, 0x23, 0x02, 0x93, 0x01, 0x93, 0x5c, 0xb9, 0x02, 0xa8};
uint8_t FlushIcache[] = {0x00, 0x00, 0x52, 0xe3, 0x84, 0xff, 0xff, 0x0a, 0xd8, 0x23, 0x9f, 0xe5, 0x00, 0x20, 0x92, 0xe5};
uint8_t ClearDcache[] = {0x00, 0x00, 0xa0, 0xe3, 0x15, 0x0f, 0x07, 0xee, 0x1e, 0xff, 0x2f, 0xe1};
uint8_t VmMapEnter[] = {0xda, 0xf7, 0x85, 0xfa, 0x25, 0xf0, 0x04, 0x05, 0xd9, 0xe7};
uint8_t VmMapProtect[] = {0x1f, 0x93, 0x29, 0xd1, 0x18, 0xf0, 0x02, 0x0f, 0x2e, 0xd1};
uint8_t PE_I_can_has_debugger[] = {0x48, 0xb1, 0x06, 0x4a, 0x13, 0x68, 0x13, 0xb9};
uint8_t CodeSignEnforcement[] = "\x00\x00\x00\x00\x01\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00";

patches kernel_patches[] = {
//    {"KERNEL_CS_ENFORCEMENT", CodeSignEnforcement, sizeof(CodeSignEnforcement)},
//    {"KERNEL_TASK_FOR_PID0", TaskForPid0, sizeof(TaskForPid0)},
//    {"KERNEL_PE_DEBUGGER", PE_I_can_has_debugger, sizeof(PE_I_can_has_debugger)},
    {"KERNEL_FLUSH_ICACHE", FlushIcache, sizeof(FlushIcache)},
    {"KERNEL_FLUSH_DCACHE", ClearDcache, sizeof(ClearDcache)},
//    {"KERNEL_VM_MAP_ENTER", VmMapEnter, sizeof(VmMapEnter)},
//    {"KERNEL_VM_MAP_PROTECT", VmMapProtect, sizeof(VmMapProtect)},
    {NULL, NULL},
};

#define VMADDR      0x80001000  /* Kernel is mapped linearly. */

void patch_find_part1(void* p, int sz)
{
    printf("#\n"
           "# This file was machine generated by the kernel offset generator.\n"
           "#\n");
    
    int i;
    // XXX: Bad.
    for(i = 0; i <= sz - 8192; i++) {
        patches *cur = &kernel_patches[0];
        while(cur && (cur->name != NULL)) {
            if(!memcmp((void*)(p + i), cur->patch, cur->size)) {
                int soffset = 0;
		if(cur->patch == VmMapEnter) soffset = 4;
		if(cur->patch == VmMapProtect) soffset = 6;
		if(cur->patch == TaskForPid0) soffset = 6;
                printf("%s = 0x%08x\n", cur->name, i + VMADDR + soffset);
            }
            cur++;
        }
    }
    
    return;
}

void patch_find_part2(void* p, int sz)
{
    char unix_syscall_str[] = "\"unix_syscall: unknown return type\"";    
    int i, first_ref = 0;
    uint32_t syscall_offset;
    
    // THIS IS PROBABLY BAD AND ALL WRONG !!! 
    
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), unix_syscall_str, strlen(unix_syscall_str))) {
            if(first_ref == 0) {
                first_ref = 1;
            } else {
                syscall_offset = VMADDR + i;
                break;
            }
        }
    }
    
    /* Pass 2, look for unix_syscall */
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), &syscall_offset, sizeof(uint32_t))) {
            syscall_offset = i;
            break;
        }
    }
    
    uint32_t kernel_sysent_call0 = *(uintptr_t*)((uintptr_t)p + (uintptr_t)(syscall_offset - 8)) + 4;
    
    printf("KERNEL_SYSCALL0 = 0x%08x\n", kernel_sysent_call0);
    printf("KERNEL_SYSCALL0_VALUE = 0x%08x\n", *(uintptr_t*)(kernel_sysent_call0 - VMADDR + (uintptr_t)p));

    char pmap_page_protect_str[] = "\"pmap_page_protect: bad pve entry pve_p=%p pmap=%p, pte=0x%x, sh";
    uint32_t pmap_page_protect_krnl;
    
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), pmap_page_protect_str, strlen(pmap_page_protect_str))) {
            pmap_page_protect_krnl = VMADDR + i;
            break;
        }
    }
    
    /* Pass 4, look for pmap_page_protect */
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), &pmap_page_protect_krnl, sizeof(uint32_t))) {
            pmap_page_protect_krnl = i;
            break;
        }
    }
    
    printf("KERNEL_NX_ENABLE = 0x%08x\n", *(uintptr_t*)(pmap_page_protect_krnl + (uintptr_t)p - 8));

    char iolog_str[] = "%s: error mapping interrupt[%d]\n";
    uint32_t iolog_krnl;
    
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), iolog_str, strlen(iolog_str))) {
            iolog_krnl = VMADDR + i;
            break;
        }
    }
    
    /* Pass 4, look for pmap_page_protect */
    for(i = 0; i <= sz - 8192; i++) {
        if(!memcmp((void*)(p + i), &iolog_krnl, sizeof(uint32_t))) {
            iolog_krnl = i;
            break;
        }
    }
    
    printf("KERNEL_IOLOG = 0x%08x\n", *(uintptr_t*)(iolog_krnl + (uintptr_t)p - 4));
}

int main(int argc, char* argv[]) {
    assert(argv[1] != NULL);
    
    struct stat buf;
    assert(stat(argv[1], &buf) != -1);
    
    int fd = open(argv[1], O_RDONLY);
    assert(fd != -1);
    
    void* p = mmap(NULL, buf.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    
    patch_find_part1(p, buf.st_size);
    patch_find_part2(p, buf.st_size);
    
    munmap(p, buf.st_size);
    close(fd);
    
    return 0;
}
